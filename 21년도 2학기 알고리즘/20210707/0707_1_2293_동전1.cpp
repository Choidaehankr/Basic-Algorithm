
//dp[0]: 0원을 만드는 경우의 수 = 모두 사용하지 않음. 즉, dp[0] = 1

// 1) 1원 짜리만 사용하는 경우

// dp[i]: i원을 만드는 경우의 수: 1원 i개 사용. dp[i] = 1


// 2) 1원과 2원 동전 사용
//dp[1]: (1원 1개) = '1가지'
//dp[2]: (1원 2개) (2원 1개) dp[2] = '2가지'
//dp[3]: (1원 3개) (2원 1개, 1원 1개) = '2가지'
//dp[4]: (1원 4개) (1원 2개, 2원 1개) (2원 2개) = '3가지'
//dp[5]: (1x5) (1x3 + 2x1) (1x1 + 2x2) = '3가지'
//dp[6]: (1x6) (1x4 + 2x1) (1x2 + 2x2) (2x3) + '4가지'
//dp[7]: (1원 7개) (1원 5개, 2원 1개) (1원 3개, 2원 2개) (1원 1개, 2원 3개) = '4가지'
//dp[8]: (1x8) (1x6 + 2x1) (1x4 + 2x2) (1x2 + 2x3) (2x4) = '5가지'


// 3) 1, 2, 5원 동전 사용
// dp[1] ~ dp[4]는 변하지 않음. -> 5원 동전이 쓰이지 않기 때문에
//dp[5]: (1x5) (1x3 + 2x1) (1x1 + 2x2) (5x1): '4가지'
//dp[7]: (1x7) (1x5 + 2x1) (1x3 + 2x2) (1x1 + 2x3) (1x2 + 5x1) (2x1 + 5x1) = '6가지'

// *동전의 가치 num 보다 dp[i]에서 i의 값이 작을 경우 동전 num은 쓰이지 않음.

// 

#include <iostream>
using namespace std;

int n, k;
int arr[101] = {};
int dp[10010] = {};
int result = 0;
int sum = 0;

int main() {
	cin >> n >> k;
	for (int i = 1; i <= n; i++) {
		int num; cin >> num;
		arr[i] = num;
	}
	dp[0] = 1; // 0원을 만드는 법. 모든 동전을 쓰지 않는 것 = 1가지.

	// dp[i]에서 i의 값이 dp[i-(동전의 값)]이 될때마다 경우의 수가 증가!!

	// 만약, 현재 1,2,5 원 중에서 5원까지 사용가능하다면, 이전의 경우 (1, 2원만 사용)한 경우의 수를 더해줌.
	// dp[i] =  dp[i] + dp[i - 사용하는 동전의 값]

	// 제 부족한 머리로는 도저히 구현할 수 없어서 직접적인 솔루션을 봤습니다.


	for (int i = 1; i <= n; i++) { //첫번째 for loop는 동전의 값을 접근.
		for (int j = arr[i]; j <= k; j++) { //arr[i]원부터 k원까지 만들 수 있는 경우의 수를 업데이트 (arr[i] 보다 작은 값들은 동전을 추가로 사용하지 않으므로 PASS)
			dp[j] = dp[j] + dp[j - arr[i]]; //arr[i]원 동전까지 써서 만들 수 있는 경우의 수를 더해줌.
		}
	}

	cout << dp[k];
}